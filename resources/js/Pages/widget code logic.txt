Great — let’s walk through building this system with:

Frontend snippet/widget in JavaScript

Backend API using Laravel (PHP)

POST tracking data (name, email, partner ID, etc.) to the backend

✅ Step 1: JavaScript Snippet (Embed Code for Clients)
Your clients will embed this in their website's <head> or just before </body>:

html
Copy
Edit
<script>
  (function () {
    var s = document.createElement("script");
    s.src = "https://yourdomain.com/widget.js"; // Host this JS
    s.async = true;
    s.onload = function () {
      window.initYourWidget({ partnerId: "partner123" }); // Replace with dynamic ID
    };
    document.head.appendChild(s);
  })();
</script>
✅ Step 2: Widget JavaScript (widget.js)
Create this file on your server (public/widget.js):

javascript
Copy
Edit
window.initYourWidget = function (config) {
  const container = document.createElement("div");
  container.innerHTML = `
    <div style="position:fixed; bottom:20px; right:20px; background:#fff; border:1px solid #ccc; padding:16px; z-index:9999; box-shadow:0 0 10px rgba(0,0,0,0.1)">
      <h4 style="margin:0 0 10px;">Join Our List</h4>
      <input type="text" id="yw-name" placeholder="Your Name" style="width: 100%; margin-bottom: 6px; padding: 6px;" />
      <input type="email" id="yw-email" placeholder="Your Email" style="width: 100%; margin-bottom: 6px; padding: 6px;" />
      <button id="yw-submit" style="width: 100%; padding: 8px;">Submit</button>
      <div id="yw-message" style="margin-top: 10px; font-size: 13px;"></div>
    </div>
  `;
  document.body.appendChild(container);

  document.getElementById("yw-submit").addEventListener("click", function () {
    const name = document.getElementById("yw-name").value;
    const email = document.getElementById("yw-email").value;

    fetch("https://yourdomain.com/api/track", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        name,
        email,
        partner_id: config.partnerId,
        page_url: window.location.href,
        referrer: document.referrer,
      }),
    })
      .then((res) => res.json())
      .then((data) => {
        document.getElementById("yw-message").innerText = "Thanks! We got it.";
      })
      .catch((err) => {
        document.getElementById("yw-message").innerText = "Something went wrong.";
      });
  });
};

/*** ---- widget functionality with verified domain
 window.initYourWidget = function (config) {
  const container = document.createElement("div");
  container.style = "position:fixed; bottom:20px; right:20px; z-index:9999;";

  const currentDomain = window.location.hostname;

  fetch(`https://yourdomain.com/api/check-domain?partner_id=${config.partnerId}&domain=${currentDomain}`)
    .then(res => res.json())
    .then(data => {
      if (data.verified) {
        renderForm(container, config);
      } else {
        renderVerifyButton(container, config, currentDomain);
      }
    });
  
  document.body.appendChild(container);
};

function renderForm(container, config) {
  container.innerHTML = `
    <div style="background:#fff; border:1px solid #ccc; padding:16px;">
      <h4>Join Our List</h4>
      <input type="text" id="yw-name" placeholder="Your Name" />
      <input type="email" id="yw-email" placeholder="Your Email" />
      <button id="yw-submit">Submit</button>
      <div id="yw-message"></div>
    </div>
  `;

  document.getElementById("yw-submit").addEventListener("click", function () {
    const name = document.getElementById("yw-name").value;
    const email = document.getElementById("yw-email").value;

    fetch("https://yourdomain.com/api/track", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        name,
        email,
        partner_id: config.partnerId,
        page_url: window.location.href,
        referrer: document.referrer,
      }),
    })
      .then((res) => res.json())
      .then((data) => {
        document.getElementById("yw-message").innerText = "Thanks! We got it.";
      })
      .catch(() => {
        document.getElementById("yw-message").innerText = "Something went wrong.";
      });
  });
}

function renderVerifyButton(container, config, domain) {
  container.innerHTML = `
    <div style="background:#fff; border:1px solid red; padding:16px;">
      <p>This domain (<b>${domain}</b>) is not verified for this widget.</p>
      <button id="verify-domain">Verify this domain</button>
      <div id="verify-message" style="margin-top:10px;"></div>
    </div>
  `;

  document.getElementById("verify-domain").addEventListener("click", () => {
    fetch("https://yourdomain.com/api/verify-domain", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        partner_id: config.partnerId,
        domain: domain,
      }),
    })
      .then(res => res.json())
      .then(data => {
        document.getElementById("verify-message").innerText = "Domain verified! Refresh the page.";
      })
      .catch(() => {
        document.getElementById("verify-message").innerText = "Verification failed.";
      });
  });
}

 ---- ***/

🔒 Make sure CORS is configured on Laravel API to allow requests from any domain or selected partner domains.

✅ Step 3: Laravel Backend API
1. Create the Laravel API project
If you haven't yet:

composer create-project laravel/laravel widget-api
cd widget-api

2. Create a Controller

php artisan make:controller LeadTrackingController
In app/Http/Controllers/LeadTrackingController.php:

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\Lead;

class LeadTrackingController extends Controller
{
    public function track(Request $request)
    {
        $validated = $request->validate([
            'name'       => 'required|string|max:255',
            'email'      => 'required|email|max:255',
            'partner_id' => 'required|string|max:100',
            'page_url'   => 'nullable|url',
            'referrer'   => 'nullable|url',
        ]);

        $lead = Lead::create($validated);

        return response()->json(['message' => 'Lead captured'], 200);
    }
}

3. Create the Model and Migration

php artisan make:model Lead -m
In database/migrations/xxxx_xx_xx_create_leads_table.php:

public function up()
{
    Schema::create('leads', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->string('email');
        $table->string('partner_id');
        $table->text('page_url')->nullable();
        $table->text('referrer')->nullable();
        $table->timestamps();
    });
}
Run the migration:

php artisan migrate

4. Setup Routes
In routes/api.php:

use App\Http\Controllers\LeadTrackingController;

Route::post('/track', [LeadTrackingController::class, 'track']);
5. Add CORS Middleware (Allow Cross-Site Requests)
In config/cors.php, update:

'paths' => ['api/*'],
'allowed_origins' => ['*'], // or specify allowed domains
'allowed_methods' => ['*'],
'allowed_headers' => ['*'],
Then clear config cache:

php artisan config:clear

✅ Step 4: Optional — Send Data to Partner (Postback)
If you want to notify the partner via a webhook:

In LeadTrackingController after saving:

Http::post('https://partner-website.com/webhook', [
    'name' => $lead->name,
    'email' => $lead->email,
]);
You can also add error handling or retry logic here.

✅ Deployment Tips
Host widget.js on a CDN or your Laravel public/ directory

Secure your API with API keys or domain whitelisting (next step)

Log user consent for compliance

✅ Want Extras?
I can help you add:

Admin dashboard to view leads

Email notifications

Webhook retries

Widget customization panel per partner

/*================ new code with domain check and validate ================*/

Great — you're on the right track! To meet your new requirement:

"I want to create dynamic widgets and the widget should work only with the website it was made for."

We need to bind each widget to its authorized domain. That way, even if someone copies the script, it won’t work unless it's used on an approved website.

✅ Here's how to implement that securely:
🔐 Step 1: Store Allowed Domains for Each Partner
Update your partners table (or create a new one if it doesn’t exist) to include a domain field.

Example migration:
php
Copy
Edit
Schema::create('partners', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->string('partner_id')->unique();
    $table->string('domain'); // example: example.com or sub.example.com
    $table->timestamps();
});
Then create a Partner model:

bash
Copy
Edit
php artisan make:model Partner
🛡️ Step 2: Check Domain in Laravel API Before Saving
Update your LeadTrackingController like so:

php
Copy
Edit
use App\Models\Partner;

public function track(Request $request)
{
    $validated = $request->validate([
        'name'       => 'required|string|max:255',
        'email'      => 'required|email|max:255',
        'partner_id' => 'required|string|max:100',
        'page_url'   => 'nullable|url',
        'referrer'   => 'nullable|url',
    ]);

    // Extract origin host
    $origin = parse_url($request->headers->get('origin'), PHP_URL_HOST)
        ?? parse_url($request->headers->get('referer'), PHP_URL_HOST);

    $partner = Partner::where('partner_id', $validated['partner_id'])->first();

    if (!$partner || !$origin || stripos($origin, $partner->domain) === false) {
        return response()->json(['error' => 'Unauthorized domain'], 403);
    }

    $lead = Lead::create($validated);

    return response()->json(['message' => 'Lead captured'], 200);
}
🌐 Step 3: Add Domain on Partner Creation
When onboarding a new partner, make sure to save their domain. You can build a simple admin panel or use tinker:

bash
Copy
Edit
php artisan tinker
php
Copy
Edit
\App\Models\Partner::create([
    'name' => 'My Partner',
    'partner_id' => 'partner123',
    'domain' => 'example.com'
]);
🌍 Step 4: (Optional) Validate Domain in JS Too
You can also hardcode the domain check in the widget.js to reduce misuse:

javascript
Copy
Edit
if (!window.location.hostname.includes("example.com")) {
  console.warn("Unauthorized domain");
  return;
}
But remember: JS can be edited, so this is just a weak first line of defense. Always do final validation server-side (as above).

🔧 Extra Option: Use JWTs or Signed Tokens (Advanced)
If you want even tighter security later:

Generate signed tokens for each partner with expiry (JWTs)

Pass token in widget config

Validate it server-side

Let me know if you want help setting that up.

✅ Summary
Feature	Implementation
Widget per partner	partner_id passed via config
Bind widget to one website	Store and validate domain in backend
Prevent misuse	Validate domain from Origin or Referer
Optional: JS-side check	Weak check in widget.js

Let me know if you'd like:

Admin UI to manage partners

Widget customization per domain

Full installation script for new partners

Want me to generate the full updated controller code with domain checks and the Partner model?



You said:
if (!window.location.hostname.includes("example.com")) { console.warn("Unauthorized domain"); return; }

i also want first user validates the widget by clicking some button and then able to use the widget in his website

ChatGPT said:
Perfect — what you want now is manual verification before allowing a partner to use the widget:

✅ A partner must "verify" the widget first (e.g., click a validation button) before it becomes usable on their website.

This adds an important access control step to your widget distribution.

✅ Here’s the Updated Plan
🔁 Workflow
Partner signs up (or you create their profile).

They embed the widget on their site, but it shows a "Not verified" message.

They click a "Verify this domain" button in the widget.

Your backend stores the verified domain.

From now on, only that domain can use the widget.

🔨 Step-by-Step Implementation
✅ Step 1: Update the Partner Model
Add a verified_domain field to the partners table:

bash
Copy
Edit
php artisan make:migration add_verified_domain_to_partners_table
Migration:

php
Copy
Edit
Schema::table('partners', function (Blueprint $table) {
    $table->string('verified_domain')->nullable()->after('domain');
});
Then run:

bash
Copy
Edit
php artisan migrate
✅ Step 2: Add a /verify API Route
Add this to routes/api.php:

php
Copy
Edit
use App\Http\Controllers\WidgetVerificationController;

Route::post('/verify-domain', [WidgetVerificationController::class, 'verify']);
Create the controller:

bash
Copy
Edit
php artisan make:controller WidgetVerificationController
In WidgetVerificationController.php:

php
Copy
Edit
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\Partner;

class WidgetVerificationController extends Controller
{
    public function verify(Request $request)
    {
        $validated = $request->validate([
            'partner_id' => 'required|string',
            'domain'     => 'required|string',
        ]);

        $partner = Partner::where('partner_id', $validated['partner_id'])->first();

        if (!$partner) {
            return response()->json(['error' => 'Partner not found'], 404);
        }

        $partner->verified_domain = $validated['domain'];
        $partner->save();

        return response()->json(['message' => 'Domain verified']);
    }
}
✅ Step 3: Update Your JavaScript Widget Logic
Update widget.js to:

Detect the current domain.

Check if the domain is verified via the backend.

Show either:

The form if verified

A "Verify this domain" button if not

widget.js – Simplified Version:
javascript
Copy
Edit
window.initYourWidget = function (config) {
  const container = document.createElement("div");
  container.style = "position:fixed; bottom:20px; right:20px; z-index:9999;";

  const currentDomain = window.location.hostname;

  fetch(`https://yourdomain.com/api/check-domain?partner_id=${config.partnerId}&domain=${currentDomain}`)
    .then(res => res.json())
    .then(data => {
      if (data.verified) {
        renderForm(container, config);
      } else {
        renderVerifyButton(container, config, currentDomain);
      }
    });
  
  document.body.appendChild(container);
};

function renderForm(container, config) {
  container.innerHTML = `
    <div style="background:#fff; border:1px solid #ccc; padding:16px;">
      <h4>Join Our List</h4>
      <input type="text" id="yw-name" placeholder="Your Name" />
      <input type="email" id="yw-email" placeholder="Your Email" />
      <button id="yw-submit">Submit</button>
      <div id="yw-message"></div>
    </div>
  `;

  document.getElementById("yw-submit").addEventListener("click", function () {
    const name = document.getElementById("yw-name").value;
    const email = document.getElementById("yw-email").value;

    fetch("https://yourdomain.com/api/track", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        name,
        email,
        partner_id: config.partnerId,
        page_url: window.location.href,
        referrer: document.referrer,
      }),
    })
      .then((res) => res.json())
      .then((data) => {
        document.getElementById("yw-message").innerText = "Thanks! We got it.";
      })
      .catch(() => {
        document.getElementById("yw-message").innerText = "Something went wrong.";
      });
  });
}

function renderVerifyButton(container, config, domain) {
  container.innerHTML = `
    <div style="background:#fff; border:1px solid red; padding:16px;">
      <p>This domain (<b>${domain}</b>) is not verified for this widget.</p>
      <button id="verify-domain">Verify this domain</button>
      <div id="verify-message" style="margin-top:10px;"></div>
    </div>
  `;

  document.getElementById("verify-domain").addEventListener("click", () => {
    fetch("https://yourdomain.com/api/verify-domain", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        partner_id: config.partnerId,
        domain: domain,
      }),
    })
      .then(res => res.json())
      .then(data => {
        document.getElementById("verify-message").innerText = "Domain verified! Refresh the page.";
      })
      .catch(() => {
        document.getElementById("verify-message").innerText = "Verification failed.";
      });
  });
}
✅ Step 4: Add Domain Check API
In routes/api.php:

php
Copy
Edit
Route::get('/check-domain', function (Request $request) {
    $partner = \App\Models\Partner::where('partner_id', $request->partner_id)->first();

    $isVerified = $partner && $partner->verified_domain === $request->domain;

    return response()->json(['verified' => $isVerified]);
});
✅ Result
Now your widget:

Does nothing until the domain is verified by the partner.

Allows you to control widget use per domain.

Can still enforce backend domain restrictions in /track for added security.

✅ Want a Dashboard for This?
You can build a simple dashboard:

Create/edit partner info (name, domain, etc.)

View leads per partner

Approve or deny domains manually if needed

Let me know if you want a basic admin panel template too.